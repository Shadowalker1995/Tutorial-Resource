WEBVTT

00:06.550 --> 00:12.970
Welcome everyone to this quick crash course overview lecture on pi which is a numerical Python library

00:13.260 --> 00:17.180
and we're such it is going to show you the very basics of it and how we're going to use in this course.

00:17.200 --> 00:19.450
Let's open up a Jupiter notebook and get started.

00:20.330 --> 00:25.910
All right so here I am with a new Jupiter notebook and the first thing to do is important up-I as MP

00:26.450 --> 00:30.390
and let's go over a couple of ways so we can create arrays.

00:30.500 --> 00:36.140
So we're already familiar a python list 1 2 3 which is elements in a sequence.

00:36.170 --> 00:41.570
And if I want to convert this into an empire array and I can say end dot and if hit tab here you'll

00:41.570 --> 00:46.130
notice that there's a ton a ton of functions that are built into non-pay the majority of these we will

00:46.130 --> 00:49.400
never use but we may be using array.

00:49.610 --> 00:55.750
So you can cast a really transform a list into an array.

00:55.850 --> 00:58.720
So if you run that you can see now it's an array.

00:58.970 --> 01:04.730
And if you check the type of this object it's no longer just the list but instead it's a PI and D array

01:04.790 --> 01:06.950
meaning and dimensional array.

01:06.980 --> 01:07.270
OK.

01:07.310 --> 01:15.650
So then we could also save this or assign it to a variable and then call back that variable later on.

01:15.690 --> 01:18.690
And again remember it's just shift and try to run a cell.

01:18.720 --> 01:21.340
Now that's the way you can cast a list into an array.

01:21.350 --> 01:26.550
But lots of times we'll be using a lot of built in functions with no PI to create large arrays very

01:26.550 --> 01:27.540
quickly.

01:27.540 --> 01:33.330
So one way to do that is by using the arr. function that's built into non-pay again just clicking tab

01:33.330 --> 01:36.590
there to auto complete and arranged the way it works.

01:36.580 --> 01:41.070
If you do shift tab here will basically tell you it's essentially non-pay his version of Python's normal

01:41.070 --> 01:47.250
range function where you indicate a start a stop and then as an option a step size.

01:47.250 --> 01:50.090
For example I can say start at zero.

01:50.100 --> 01:51.930
Whoops let me make sure I click on that.

01:52.140 --> 02:00.810
Start at zero go up tube and not including 10 and then I'll see 0 through 9 here so you can see that

02:00.840 --> 02:05.110
we have 10 elements in array evenly spaced by one.

02:05.130 --> 02:08.060
Don't be confused by the fact that it doesn't go all the way to 10.

02:08.070 --> 02:11.440
It's because it's going up to but not including that last stopping.

02:11.460 --> 02:17.010
So if you actually wanted this to be 0 310 you would have to put an 11 here and then you would get back

02:17.100 --> 02:20.280
0 through 10 which would be 11 elements.

02:20.280 --> 02:25.170
Now if you actually want to indicate a step size for instance you all the even numbers as a third argument

02:25.200 --> 02:27.360
you can indicate hey go in steps of two.

02:27.480 --> 02:31.700
And then when you run this you can see have zero to four six eight 10 etc..

02:31.860 --> 02:32.780
So that's a range.

02:32.800 --> 02:35.050
Again a start stop and step size.

02:35.100 --> 02:41.910
Very similar to pythons Bilton range function non-employee also has lots of useful tools for quickly

02:41.910 --> 02:45.090
creating specific arrays such as an array of zeros.

02:45.090 --> 02:51.950
So zeroes can either just take in one digit or one integer and will return back a one dimensional array.

02:52.170 --> 02:57.830
You can see here it returned back five zeros or instead you can pass any tuple of dimensions.

02:57.900 --> 03:03.570
Maybe you want a three by five array or matrix A two dimensional array.

03:03.570 --> 03:08.650
And when you're in that you can see here I have three rows and then five columns of zeros.

03:08.670 --> 03:14.100
So that's the way zeros works essentially returns back an n dimensional array pending on what you pass

03:14.100 --> 03:16.520
in the dimensions of that where they're all zeros.

03:16.560 --> 03:21.480
And note that it has a decimal point here in the Kading that these are actually all floating points

03:22.380 --> 03:27.660
versus integers so we had over in a range and a lot of times with the operations we perform with tensor

03:27.660 --> 03:32.910
flow and Python non-place going to be transforming things to floats to make sure that we don't accidentally

03:33.120 --> 03:34.820
lose information.

03:34.860 --> 03:39.600
OK so now let's go ahead and discuss a couple of more ways of creating arrays.

03:39.600 --> 03:41.360
There is also a similar ones function.

03:41.370 --> 03:42.520
Same deal here.

03:42.580 --> 03:46.190
If you pass on a single integer it's going to bring back an array of ones.

03:46.190 --> 03:48.300
No again that their floating point numbers.

03:48.480 --> 03:54.330
And then we can do something like a 3 by 5 and pass that in as a tuple.

03:54.510 --> 03:57.050
Although I believe it doesn't matter either way.

03:57.060 --> 04:05.370
Here we go through by five three ones by five ones and there's ways of creating linearly spaced arrays.

04:05.850 --> 04:14.510
So there's lende space and basically Lance Bass works by you providing a starting point a stopping point

04:14.600 --> 04:21.110
and then the number of elements you want evenly spaced or linearly spaced between the start and the

04:21.110 --> 04:22.180
stop.

04:22.190 --> 04:31.490
For example if I want to start at zero and go to 11 and I wants 10 points there that are evenly spaced

04:31.550 --> 04:32.530
it's going to return back.

04:32.540 --> 04:38.870
This right here if I want 11 points that are evenly spaced then I can see jumping up in steps of 1.1

04:39.180 --> 04:45.830
then two point two three point three etc. if I want 100 points between 0 and 11 that are evenly spaced

04:46.010 --> 04:49.070
then it goes zero all the way to 11.

04:49.070 --> 04:56.210
So the difference here between linearly spaced and arrange arranged takes in a start and stop and then

04:56.360 --> 05:02.390
it you actually define what jump or what steps size you want to take as you go along linearly spaced

05:02.390 --> 05:05.900
or space instead again start stop.

05:05.960 --> 05:09.170
But then you say how many points do you want evenly spaced between that.

05:09.350 --> 05:13.170
So you could ask for just five points evenly spaced between that.

05:13.280 --> 05:18.320
Or you could ask for 5000 points evenly spaced between that and know here if you ask for a super large

05:18.320 --> 05:19.640
array back in Jupiter.

05:19.640 --> 05:21.910
It just indicates a dot dot dot.

05:23.000 --> 05:24.240
So that's one space.

05:24.290 --> 05:25.420
Very useful to know.

05:25.670 --> 05:29.230
Let's go ahead and cover a random number hirees.

05:29.330 --> 05:33.940
A lot of times we're dealing with neural networks you have to initialize things for in them values.

05:34.190 --> 05:36.920
So implies a really nice random library.

05:36.920 --> 05:43.070
You can say that random dots and then hit tab here and there's lots and lots of functions that are included

05:43.070 --> 05:44.090
in this random Library.

05:44.090 --> 05:45.250
We'll be using all of them.

05:45.530 --> 05:48.230
But we'll introduce a few of the common ones.

05:48.230 --> 05:52.910
One of the common ones is Rand ants which as you may have guessed returns back a random integer.

05:52.910 --> 05:54.490
So we do shift tab here.

05:54.500 --> 05:59.870
You basically give it a low number and a high number and then you can also indicate a size so the dimensions

05:59.870 --> 06:00.550
you want.

06:00.710 --> 06:05.360
And note that the low number is inclusive and the high number is exclusive.

06:05.660 --> 06:06.790
So show an example of that.

06:06.800 --> 06:13.900
Let's say just want one random number between 0 and 10 where 0 is inclusive tennis exclusive.

06:14.180 --> 06:16.030
You run that and you get back 6.

06:16.100 --> 06:19.020
If I run this again I get back zero run again.

06:19.130 --> 06:23.480
So every time I run this I'm going to get back a different read that number every time.

06:23.480 --> 06:24.850
And sometimes it gets repeated.

06:25.040 --> 06:26.860
So there we got three zeros in a row.

06:26.960 --> 06:32.480
If we make this larger we won't see as many repeated values because the likelihoods are 1 in 1000 here.

06:32.680 --> 06:32.890
OK.

06:32.900 --> 06:34.470
So just random integers.

06:34.490 --> 06:35.560
That's how it works.

06:35.550 --> 06:40.290
And if you want dimensions there I want three by three.

06:40.410 --> 06:44.160
Two dimensional array or a matrix of random integers.

06:44.160 --> 06:46.010
I can run that and there they are.

06:46.050 --> 06:47.460
So read this again.

06:47.520 --> 06:49.170
Now there's that are random integers.

06:49.170 --> 06:51.660
Now there's other random ones that we're going to be using.

06:51.660 --> 06:56.300
Things like random normal is another common one.

06:56.580 --> 06:58.680
So you can give a location a scale.

06:58.680 --> 07:02.150
It just draws random samples from a normal or Gaussian distribution.

07:02.160 --> 07:06.630
There's lots of round distributions that you can choose so keep that in mind we'll introduce those throughout

07:06.630 --> 07:08.590
the course as we encounter them.

07:08.820 --> 07:13.900
So to finish off our discussion of Nim Pye's ran the module I want to talk about setting a random seed.

07:14.110 --> 07:18.000
And that's going to be important to make sure that the random numbers I generate are the same as the

07:18.000 --> 07:19.450
array and the numbers you generate.

07:20.260 --> 07:24.080
So Nesle go ahead and type N.P. that random seed.

07:24.430 --> 07:27.270
And then you can see the generator of the ran the numbers.

07:27.310 --> 07:31.290
And typically I use the value 101 may change it up.

07:31.450 --> 07:39.990
But what's important here is now if I say any random thought ran It's a let's say 0 1000.

07:40.060 --> 07:44.900
Give me 10 random numbers run this I get back starting from 95.

07:44.900 --> 07:47.710
A much more in numbers than in 40.

07:47.800 --> 07:48.590
However no.

07:48.640 --> 07:54.970
If I were to run again I constantly get back the same ran the numbers and that's because I've set this

07:55.030 --> 07:56.870
random seed.

07:56.890 --> 08:02.500
The important thing to note here is that this random seed is currently in the same cell as this random

08:02.500 --> 08:03.640
integer command.

08:03.790 --> 08:10.630
And that's important because if I were to copy and paste this into another cell I won't get back the

08:10.630 --> 08:14.200
same random integers because that's the second time I run this.

08:14.200 --> 08:18.610
So if I want to make sure that I constantly get back the same or intimidators I want to make sure that

08:18.610 --> 08:20.700
I'm resetting that seat every time.

08:20.710 --> 08:27.520
So again make sure that that seed is in the same cell as whatever operation is generating random numbers

08:27.520 --> 08:30.270
to make sure that you're actually taking into account that seed.

08:30.280 --> 08:35.350
Because if I keep running it outside of this then even though I set that seed it's going to keep generating

08:35.410 --> 08:36.560
as I ask for them.

08:36.560 --> 08:43.020
I have to reset the seed in order to get back that same sequence of random numbers.

08:43.060 --> 08:47.920
OK that's basically all we need to know about creating an umpire or raise either one dimensional or

08:47.920 --> 08:48.580
two dimensional.

08:48.580 --> 08:54.140
Later on we'll learn about tensors which are essentially three dimensional and dimensional arrays.

08:54.410 --> 08:58.290
We're going to do now is quickly cover a few useful operations.

08:58.420 --> 09:02.950
So if I have an array here that's going to generate run we'll see a random rant.

09:03.010 --> 09:03.990
It's 0.

09:03.990 --> 09:05.480
One hundred ten.

09:05.480 --> 09:10.820
And let's go ahead and grab that see just to make sure that we get the same numbers here.

09:10.990 --> 09:12.190
So I ask for the survey.

09:12.220 --> 09:14.080
You should have the same numbers I do.

09:14.200 --> 09:18.130
If you want to find the max value of an array you can just say Max.

09:18.130 --> 09:20.940
Call it like that if you want to find the minimum.

09:21.250 --> 09:22.720
You can just call minimum.

09:22.750 --> 09:26.950
There's lots of other functions and methods you can call here if hit tab you can see a bunch of them

09:26.950 --> 09:29.380
here who definitely won't be using all of these.

09:29.470 --> 09:32.270
A lot of this is happening in the background with tensor flow.

09:32.590 --> 09:37.390
But you can do things like also grab the average what's also really nice is that if you want to grab

09:37.720 --> 09:43.870
the index location of the max value so the max value here is ninety five bullets say this is a huge

09:43.870 --> 09:44.310
array.

09:44.350 --> 09:50.440
And I want to know whereas the actual index location of that max value I can use our emacs and that

09:50.440 --> 09:54.440
returns back zero which is the index location of that max value.

09:54.490 --> 09:59.200
And there's the same operation for Argemone or it's going to return the index position of the minimum

09:59.200 --> 10:02.130
value and very quickly too.

10:02.150 --> 10:04.120
And there is discussion of Empire operations.

10:04.140 --> 10:07.030
I want to discuss the reshape method often IRA.

10:07.320 --> 10:12.480
So if I take a look at my array right now it's one dimensional and just 10 elements but I can actually

10:12.480 --> 10:15.560
reshape this using the reshape command.

10:15.750 --> 10:22.380
And here I can reshape it into whatever shape I want as long as the 10 elements out evenly.

10:22.380 --> 10:25.950
For example I can reshape this into a 2 by 5 array.

10:26.250 --> 10:32.900
And here I have the two rows with five columns and we'll be using reshape to reshape tensors a lot.

10:32.910 --> 10:34.000
So again reshape.

10:34.020 --> 10:34.650
Very useful.

10:34.650 --> 10:36.690
It just reshapes an array.

10:36.690 --> 10:39.550
Finally let's go ahead and discuss indexing.

10:39.700 --> 10:41.920
So I'm going to create a matrix.

10:42.340 --> 10:44.940
We'll say in Empire range 0 to 100.

10:45.070 --> 10:48.320
And then I'm going to call reshape off of this to be a 10 by 10.

10:48.520 --> 10:53.500
And this sort of stacks methods on a higher rate is really common.

10:54.670 --> 11:01.360
So now I have a nice numb piracy Ray 0 through 99 rubber goes up to about including 100 and it's 10

11:01.360 --> 11:01.910
by 10.

11:01.930 --> 11:03.800
So it includes a there.

11:04.090 --> 11:10.840
So the way I can grab stuff if I just want to grab a single element let's say I wanted to grab the value

11:10.930 --> 11:19.500
of the safe first row second column what I could do is say mats or whatever the name of your time to

11:19.500 --> 11:20.610
the missional array is.

11:20.800 --> 11:26.620
And then you passen the row you want starting at index 0 and then you can pasand the column you want.

11:26.620 --> 11:30.730
So in this case I want column 1 and this should return the value 1.

11:30.760 --> 11:32.050
So let's go in practice.

11:32.080 --> 11:34.830
Go ahead and choose a random number here going to choose 43.

11:35.050 --> 11:36.890
So let's try to index up 43.

11:37.060 --> 11:39.700
That's 0 1 2 3 4.

11:39.700 --> 11:46.770
So it's in the fourth row and then column wise 43 is 0 1 2 3.

11:46.780 --> 11:48.490
So let's go ahead and put in 3 here.

11:48.760 --> 11:50.800
Run this and then we have 43.

11:50.830 --> 11:56.590
So again it's just the index location by RHO comma in the location by column.

11:56.590 --> 12:01.380
So that is how you can get a single element out of a to them array.

12:01.450 --> 12:08.170
You can also use slicing to grab chunks of the story and it works just like regular Python slicing.

12:08.290 --> 12:14.740
So let's go ahead and say Matt let's say I want all the rows in the first column.

12:14.950 --> 12:20.590
So that is I want all these rows 0 10 20 30 but just for the first column.

12:20.590 --> 12:23.390
So essentially I just want 0 10 20 30 40 etc..

12:23.620 --> 12:28.570
What I would do is I would use colon to indicate everything as far as Rose is concerned.

12:28.570 --> 12:34.280
And then I can pass in zero to indicate that I only want that first column index 0 run that.

12:34.320 --> 12:38.350
Now I can see you have an array here 0 10 20 30 etc..

12:38.360 --> 12:40.570
I can also do kind of the opposite effect.

12:40.630 --> 12:43.340
So grab all the columns in a particular row.

12:43.390 --> 12:51.080
So if I just wanted to essentially return back a single row I could say five comma colon returns back

12:51.170 --> 12:54.830
that entire row a little weird because you kind of think about it backwards.

12:54.830 --> 12:59.440
The fact they are selecting all columns for one row returns back the whole row.

12:59.600 --> 13:01.070
But that's the way it works.

13:01.070 --> 13:05.780
Again it's fro comma column and you can use colon to indicate everything.

13:06.080 --> 13:07.610
Then you can also do slices.

13:07.670 --> 13:16.400
Let's take a look at our matrix again 0 through 99 and then we're going to say Matt here and let's go

13:16.400 --> 13:18.530
ahead and grab just this first trunk.

13:18.590 --> 13:23.130
0 1 2 10 11 12 20 21 22.

13:23.140 --> 13:30.660
What I'm going to do here then is first slice off my rows so the rows I want is zero 10 20.

13:30.680 --> 13:36.100
So that is starting at index 0 up to but not including three.

13:36.200 --> 13:41.900
So that's 0 1 2 to get I'm up going up to bet on including that third index.

13:41.900 --> 13:44.530
Or really that fourth row index three.

13:44.900 --> 13:48.140
And then we're going to do essentially the same thing for 0 1 2.

13:48.320 --> 13:55.370
So I'm sorry column 0 then slicing all the way and not including that index three there.

13:56.170 --> 14:01.310
And that should return back 0 1 to 10 11 12 20 21 22.

14:01.310 --> 14:05.660
So this is confusing to you go ahead and practice a little bit so see if you can select kind of random

14:05.660 --> 14:08.190
chunks from this array and go ahead and index them.

14:08.240 --> 14:13.580
The most confusing part I believe for beginners is the fact that it goes up to an not including that

14:13.730 --> 14:16.290
last slice index.

14:16.470 --> 14:18.920
Finally let's go ahead and discuss masking.

14:18.920 --> 14:22.420
So masking is a super useful attribute of pi.

14:22.440 --> 14:24.050
So I want to show it off.

14:24.120 --> 14:28.180
Basically if you have a matrix here you can perform a Boolean operation on it.

14:28.200 --> 14:34.530
For example I could ask Hey where is this matrix A greater than 50 and it'll return back a matrix of

14:34.530 --> 14:38.970
boolean values and see the start as false and then once it becomes great and the fifth day they all

14:38.970 --> 14:40.340
start returning true.

14:40.500 --> 14:46.530
If I actually wanted to only select those values I don't want just this to the matrix of boolean values

14:46.560 --> 14:49.860
but instead I want the actual values we can end up doing is the following.

14:49.860 --> 14:57.790
We can say something like My filter is equal to this and then I'll grab my matrix again and pasan filter

14:59.210 --> 15:02.270
and then it returns back all the values that have to be greater than 50.

15:02.390 --> 15:06.200
And there they are typically you don't see this done in two steps.

15:06.210 --> 15:08.980
So instead what you end up seeing is something like Matt.

15:09.320 --> 15:11.740
And then inside of that Matt greater than 50.

15:12.140 --> 15:16.750
And this is known as Boullion masking or just masking in general it's super useful.

15:16.940 --> 15:19.300
And we'll be seeing it a little bit throughout this course.

15:19.560 --> 15:20.040
OK.

15:20.240 --> 15:21.460
That's really all there is to it.

15:21.470 --> 15:25.610
You can go ahead and review the notebook in case you want any of the code I ran here.

15:25.610 --> 15:30.080
Thanks everyone and I'll see you at the next lecture or we'll quickly do a crash course for pandas which

15:30.080 --> 15:31.460
is built directly off of them by.
